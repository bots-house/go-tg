// Code generated by go-swagger; DO NOT EDIT.

package catalog

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"net/http"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/runtime/middleware"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NewGetLotsParams creates a new GetLotsParams object
// with the default values initialized.
func NewGetLotsParams() GetLotsParams {

	var (
		// initialize parameters with default values

		sortByDefault     = string("created_at")
		sortByTypeDefault = string("desc")
	)

	return GetLotsParams{
		SortBy: &sortByDefault,

		SortByType: &sortByTypeDefault,
	}
}

// GetLotsParams contains all the bound params for the get lots operation
// typically these are obtained from a http.Request
//
// swagger:parameters getLots
type GetLotsParams struct {

	// HTTP Request Object
	HTTPRequest *http.Request `json:"-"`

	/*суточный охват от
	  In: query
	*/
	DailyCoverageFrom *int64
	/*суточный охват до
	  In: query
	*/
	DailyCoverageTo *int64
	/*От кол-ва пдп
	  In: query
	*/
	MembersCountFrom *int64
	/*До кол-ва пдп
	  In: query
	*/
	MembersCountTo *int64
	/*Месячный доход от
	  In: query
	*/
	MonthlyIncomeFrom *int64
	/*Месячный доход до
	  In: query
	*/
	MonthlyIncomeTo *int64
	/*Окупаемость в месацах от
	  In: query
	*/
	PaybackPeriodFrom *float64
	/*Окупаемость в месацах до
	  In: query
	*/
	PaybackPeriodTo *float64
	/*Цена от
	  In: query
	*/
	PriceFrom *int64
	/*Цена пдп от
	  In: query
	*/
	PricePerMemberFrom *float64
	/*Цена пдп до
	  In: query
	*/
	PricePerMemberTo *float64
	/*Цена просмотра от
	  In: query
	*/
	PricePerViewFrom *float64
	/*Цена просмотра до
	  In: query
	*/
	PricePerViewTo *float64
	/*Цена до
	  In: query
	*/
	PriceTo *int64
	/*
	  In: query
	  Default: "created_at"
	*/
	SortBy *string
	/*
	  In: query
	  Default: "desc"
	*/
	SortByType *string
	/*Фильтрация по ID категорий
	  In: query
	*/
	Topics []int64
}

// BindRequest both binds and validates a request, it assumes that complex things implement a Validatable(strfmt.Registry) error interface
// for simple values it will use straight method calls.
//
// To ensure default values, the struct must have been initialized with NewGetLotsParams() beforehand.
func (o *GetLotsParams) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {
	var res []error

	o.HTTPRequest = r

	qs := runtime.Values(r.URL.Query())

	qDailyCoverageFrom, qhkDailyCoverageFrom, _ := qs.GetOK("daily_coverage_from")
	if err := o.bindDailyCoverageFrom(qDailyCoverageFrom, qhkDailyCoverageFrom, route.Formats); err != nil {
		res = append(res, err)
	}

	qDailyCoverageTo, qhkDailyCoverageTo, _ := qs.GetOK("daily_coverage_to")
	if err := o.bindDailyCoverageTo(qDailyCoverageTo, qhkDailyCoverageTo, route.Formats); err != nil {
		res = append(res, err)
	}

	qMembersCountFrom, qhkMembersCountFrom, _ := qs.GetOK("members_count_from")
	if err := o.bindMembersCountFrom(qMembersCountFrom, qhkMembersCountFrom, route.Formats); err != nil {
		res = append(res, err)
	}

	qMembersCountTo, qhkMembersCountTo, _ := qs.GetOK("members_count_to")
	if err := o.bindMembersCountTo(qMembersCountTo, qhkMembersCountTo, route.Formats); err != nil {
		res = append(res, err)
	}

	qMonthlyIncomeFrom, qhkMonthlyIncomeFrom, _ := qs.GetOK("monthly_income_from")
	if err := o.bindMonthlyIncomeFrom(qMonthlyIncomeFrom, qhkMonthlyIncomeFrom, route.Formats); err != nil {
		res = append(res, err)
	}

	qMonthlyIncomeTo, qhkMonthlyIncomeTo, _ := qs.GetOK("monthly_income_to")
	if err := o.bindMonthlyIncomeTo(qMonthlyIncomeTo, qhkMonthlyIncomeTo, route.Formats); err != nil {
		res = append(res, err)
	}

	qPaybackPeriodFrom, qhkPaybackPeriodFrom, _ := qs.GetOK("payback_period_from")
	if err := o.bindPaybackPeriodFrom(qPaybackPeriodFrom, qhkPaybackPeriodFrom, route.Formats); err != nil {
		res = append(res, err)
	}

	qPaybackPeriodTo, qhkPaybackPeriodTo, _ := qs.GetOK("payback_period_to")
	if err := o.bindPaybackPeriodTo(qPaybackPeriodTo, qhkPaybackPeriodTo, route.Formats); err != nil {
		res = append(res, err)
	}

	qPriceFrom, qhkPriceFrom, _ := qs.GetOK("price_from")
	if err := o.bindPriceFrom(qPriceFrom, qhkPriceFrom, route.Formats); err != nil {
		res = append(res, err)
	}

	qPricePerMemberFrom, qhkPricePerMemberFrom, _ := qs.GetOK("price_per_member_from")
	if err := o.bindPricePerMemberFrom(qPricePerMemberFrom, qhkPricePerMemberFrom, route.Formats); err != nil {
		res = append(res, err)
	}

	qPricePerMemberTo, qhkPricePerMemberTo, _ := qs.GetOK("price_per_member_to")
	if err := o.bindPricePerMemberTo(qPricePerMemberTo, qhkPricePerMemberTo, route.Formats); err != nil {
		res = append(res, err)
	}

	qPricePerViewFrom, qhkPricePerViewFrom, _ := qs.GetOK("price_per_view_from")
	if err := o.bindPricePerViewFrom(qPricePerViewFrom, qhkPricePerViewFrom, route.Formats); err != nil {
		res = append(res, err)
	}

	qPricePerViewTo, qhkPricePerViewTo, _ := qs.GetOK("price_per_view_to")
	if err := o.bindPricePerViewTo(qPricePerViewTo, qhkPricePerViewTo, route.Formats); err != nil {
		res = append(res, err)
	}

	qPriceTo, qhkPriceTo, _ := qs.GetOK("price_to")
	if err := o.bindPriceTo(qPriceTo, qhkPriceTo, route.Formats); err != nil {
		res = append(res, err)
	}

	qSortBy, qhkSortBy, _ := qs.GetOK("sort_by")
	if err := o.bindSortBy(qSortBy, qhkSortBy, route.Formats); err != nil {
		res = append(res, err)
	}

	qSortByType, qhkSortByType, _ := qs.GetOK("sort_by_type")
	if err := o.bindSortByType(qSortByType, qhkSortByType, route.Formats); err != nil {
		res = append(res, err)
	}

	qTopics, qhkTopics, _ := qs.GetOK("topics")
	if err := o.bindTopics(qTopics, qhkTopics, route.Formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// bindDailyCoverageFrom binds and validates parameter DailyCoverageFrom from query.
func (o *GetLotsParams) bindDailyCoverageFrom(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("daily_coverage_from", "query", "int64", raw)
	}
	o.DailyCoverageFrom = &value

	return nil
}

// bindDailyCoverageTo binds and validates parameter DailyCoverageTo from query.
func (o *GetLotsParams) bindDailyCoverageTo(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("daily_coverage_to", "query", "int64", raw)
	}
	o.DailyCoverageTo = &value

	return nil
}

// bindMembersCountFrom binds and validates parameter MembersCountFrom from query.
func (o *GetLotsParams) bindMembersCountFrom(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("members_count_from", "query", "int64", raw)
	}
	o.MembersCountFrom = &value

	return nil
}

// bindMembersCountTo binds and validates parameter MembersCountTo from query.
func (o *GetLotsParams) bindMembersCountTo(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("members_count_to", "query", "int64", raw)
	}
	o.MembersCountTo = &value

	return nil
}

// bindMonthlyIncomeFrom binds and validates parameter MonthlyIncomeFrom from query.
func (o *GetLotsParams) bindMonthlyIncomeFrom(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("monthly_income_from", "query", "int64", raw)
	}
	o.MonthlyIncomeFrom = &value

	return nil
}

// bindMonthlyIncomeTo binds and validates parameter MonthlyIncomeTo from query.
func (o *GetLotsParams) bindMonthlyIncomeTo(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("monthly_income_to", "query", "int64", raw)
	}
	o.MonthlyIncomeTo = &value

	return nil
}

// bindPaybackPeriodFrom binds and validates parameter PaybackPeriodFrom from query.
func (o *GetLotsParams) bindPaybackPeriodFrom(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertFloat64(raw)
	if err != nil {
		return errors.InvalidType("payback_period_from", "query", "float64", raw)
	}
	o.PaybackPeriodFrom = &value

	return nil
}

// bindPaybackPeriodTo binds and validates parameter PaybackPeriodTo from query.
func (o *GetLotsParams) bindPaybackPeriodTo(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertFloat64(raw)
	if err != nil {
		return errors.InvalidType("payback_period_to", "query", "float64", raw)
	}
	o.PaybackPeriodTo = &value

	return nil
}

// bindPriceFrom binds and validates parameter PriceFrom from query.
func (o *GetLotsParams) bindPriceFrom(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("price_from", "query", "int64", raw)
	}
	o.PriceFrom = &value

	return nil
}

// bindPricePerMemberFrom binds and validates parameter PricePerMemberFrom from query.
func (o *GetLotsParams) bindPricePerMemberFrom(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertFloat64(raw)
	if err != nil {
		return errors.InvalidType("price_per_member_from", "query", "float64", raw)
	}
	o.PricePerMemberFrom = &value

	return nil
}

// bindPricePerMemberTo binds and validates parameter PricePerMemberTo from query.
func (o *GetLotsParams) bindPricePerMemberTo(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertFloat64(raw)
	if err != nil {
		return errors.InvalidType("price_per_member_to", "query", "float64", raw)
	}
	o.PricePerMemberTo = &value

	return nil
}

// bindPricePerViewFrom binds and validates parameter PricePerViewFrom from query.
func (o *GetLotsParams) bindPricePerViewFrom(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertFloat64(raw)
	if err != nil {
		return errors.InvalidType("price_per_view_from", "query", "float64", raw)
	}
	o.PricePerViewFrom = &value

	return nil
}

// bindPricePerViewTo binds and validates parameter PricePerViewTo from query.
func (o *GetLotsParams) bindPricePerViewTo(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertFloat64(raw)
	if err != nil {
		return errors.InvalidType("price_per_view_to", "query", "float64", raw)
	}
	o.PricePerViewTo = &value

	return nil
}

// bindPriceTo binds and validates parameter PriceTo from query.
func (o *GetLotsParams) bindPriceTo(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("price_to", "query", "int64", raw)
	}
	o.PriceTo = &value

	return nil
}

// bindSortBy binds and validates parameter SortBy from query.
func (o *GetLotsParams) bindSortBy(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewGetLotsParams()
		return nil
	}

	o.SortBy = &raw

	if err := o.validateSortBy(formats); err != nil {
		return err
	}

	return nil
}

// validateSortBy carries on validations for parameter SortBy
func (o *GetLotsParams) validateSortBy(formats strfmt.Registry) error {

	if err := validate.EnumCase("sort_by", "query", *o.SortBy, []interface{}{"members_count", "price", "price_per_member", "price_per_view", "daily_coverage", "monthly_income", "payback_period", "created_at"}, true); err != nil {
		return err
	}

	return nil
}

// bindSortByType binds and validates parameter SortByType from query.
func (o *GetLotsParams) bindSortByType(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false
	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewGetLotsParams()
		return nil
	}

	o.SortByType = &raw

	if err := o.validateSortByType(formats); err != nil {
		return err
	}

	return nil
}

// validateSortByType carries on validations for parameter SortByType
func (o *GetLotsParams) validateSortByType(formats strfmt.Registry) error {

	if err := validate.EnumCase("sort_by_type", "query", *o.SortByType, []interface{}{"asc", "desc"}, true); err != nil {
		return err
	}

	return nil
}

// bindTopics binds and validates array parameter Topics from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetLotsParams) bindTopics(rawData []string, hasKey bool, formats strfmt.Registry) error {

	var qvTopics string
	if len(rawData) > 0 {
		qvTopics = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	topicsIC := swag.SplitByFormat(qvTopics, "")
	if len(topicsIC) == 0 {
		return nil
	}

	var topicsIR []int64
	for i, topicsIV := range topicsIC {
		topicsI, err := swag.ConvertInt64(topicsIV)
		if err != nil {
			return errors.InvalidType(fmt.Sprintf("%s.%v", "topics", i), "query", "int64", topicsI)
		}

		topicsIR = append(topicsIR, topicsI)
	}

	o.Topics = topicsIR

	return nil
}
