// Code generated by SQLBoiler 4.1.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package dal

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Lot is an object representing the database table.
type Lot struct {
	ID                    int          `boil:"id" json:"id" toml:"id" yaml:"id"`
	OwnerID               int          `boil:"owner_id" json:"owner_id" toml:"owner_id" yaml:"owner_id"`
	ExternalID            int64        `boil:"external_id" json:"external_id" toml:"external_id" yaml:"external_id"`
	Name                  string       `boil:"name" json:"name" toml:"name" yaml:"name"`
	Avatar                null.String  `boil:"avatar" json:"avatar,omitempty" toml:"avatar" yaml:"avatar,omitempty"`
	Username              null.String  `boil:"username" json:"username,omitempty" toml:"username" yaml:"username,omitempty"`
	JoinLink              null.String  `boil:"join_link" json:"join_link,omitempty" toml:"join_link" yaml:"join_link,omitempty"`
	PriceCurrent          int          `boil:"price_current" json:"price_current" toml:"price_current" yaml:"price_current"`
	PricePrevious         null.Int     `boil:"price_previous" json:"price_previous,omitempty" toml:"price_previous" yaml:"price_previous,omitempty"`
	PriceIsBargain        bool         `boil:"price_is_bargain" json:"price_is_bargain" toml:"price_is_bargain" yaml:"price_is_bargain"`
	Comment               string       `boil:"comment" json:"comment" toml:"comment" yaml:"comment"`
	MetricsMembersCount   int          `boil:"metrics_members_count" json:"metrics_members_count" toml:"metrics_members_count" yaml:"metrics_members_count"`
	MetricsDailyCoverage  int          `boil:"metrics_daily_coverage" json:"metrics_daily_coverage" toml:"metrics_daily_coverage" yaml:"metrics_daily_coverage"`
	MetricsMonthlyIncome  int          `boil:"metrics_monthly_income" json:"metrics_monthly_income" toml:"metrics_monthly_income" yaml:"metrics_monthly_income"`
	MetricsPricePerMember float64      `boil:"metrics_price_per_member" json:"metrics_price_per_member" toml:"metrics_price_per_member" yaml:"metrics_price_per_member"`
	MetricsPricePerView   float64      `boil:"metrics_price_per_view" json:"metrics_price_per_view" toml:"metrics_price_per_view" yaml:"metrics_price_per_view"`
	MetricsPaybackPeriod  null.Float64 `boil:"metrics_payback_period" json:"metrics_payback_period,omitempty" toml:"metrics_payback_period" yaml:"metrics_payback_period,omitempty"`
	ExtraResources        null.JSON    `boil:"extra_resources" json:"extra_resources,omitempty" toml:"extra_resources" yaml:"extra_resources,omitempty"`
	CreatedAt             time.Time    `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	PaidAt                null.Time    `boil:"paid_at" json:"paid_at,omitempty" toml:"paid_at" yaml:"paid_at,omitempty"`
	ApprovedAt            null.Time    `boil:"approved_at" json:"approved_at,omitempty" toml:"approved_at" yaml:"approved_at,omitempty"`
	PublishedAt           null.Time    `boil:"published_at" json:"published_at,omitempty" toml:"published_at" yaml:"published_at,omitempty"`
	Status                string       `boil:"status" json:"status" toml:"status" yaml:"status"`
	CanceledReasonID      null.Int     `boil:"canceled_reason_id" json:"canceled_reason_id,omitempty" toml:"canceled_reason_id" yaml:"canceled_reason_id,omitempty"`
	Bio                   null.String  `boil:"bio" json:"bio,omitempty" toml:"bio" yaml:"bio,omitempty"`
	ViewsTelegram         int          `boil:"views_telegram" json:"views_telegram" toml:"views_telegram" yaml:"views_telegram"`
	ViewsSite             int          `boil:"views_site" json:"views_site" toml:"views_site" yaml:"views_site"`
	DeclineReason         null.String  `boil:"decline_reason" json:"decline_reason,omitempty" toml:"decline_reason" yaml:"decline_reason,omitempty"`
	ScheduledAt           null.Time    `boil:"scheduled_at" json:"scheduled_at,omitempty" toml:"scheduled_at" yaml:"scheduled_at,omitempty"`

	R *lotR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L lotL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var LotColumns = struct {
	ID                    string
	OwnerID               string
	ExternalID            string
	Name                  string
	Avatar                string
	Username              string
	JoinLink              string
	PriceCurrent          string
	PricePrevious         string
	PriceIsBargain        string
	Comment               string
	MetricsMembersCount   string
	MetricsDailyCoverage  string
	MetricsMonthlyIncome  string
	MetricsPricePerMember string
	MetricsPricePerView   string
	MetricsPaybackPeriod  string
	ExtraResources        string
	CreatedAt             string
	PaidAt                string
	ApprovedAt            string
	PublishedAt           string
	Status                string
	CanceledReasonID      string
	Bio                   string
	ViewsTelegram         string
	ViewsSite             string
	DeclineReason         string
	ScheduledAt           string
}{
	ID:                    "id",
	OwnerID:               "owner_id",
	ExternalID:            "external_id",
	Name:                  "name",
	Avatar:                "avatar",
	Username:              "username",
	JoinLink:              "join_link",
	PriceCurrent:          "price_current",
	PricePrevious:         "price_previous",
	PriceIsBargain:        "price_is_bargain",
	Comment:               "comment",
	MetricsMembersCount:   "metrics_members_count",
	MetricsDailyCoverage:  "metrics_daily_coverage",
	MetricsMonthlyIncome:  "metrics_monthly_income",
	MetricsPricePerMember: "metrics_price_per_member",
	MetricsPricePerView:   "metrics_price_per_view",
	MetricsPaybackPeriod:  "metrics_payback_period",
	ExtraResources:        "extra_resources",
	CreatedAt:             "created_at",
	PaidAt:                "paid_at",
	ApprovedAt:            "approved_at",
	PublishedAt:           "published_at",
	Status:                "status",
	CanceledReasonID:      "canceled_reason_id",
	Bio:                   "bio",
	ViewsTelegram:         "views_telegram",
	ViewsSite:             "views_site",
	DeclineReason:         "decline_reason",
	ScheduledAt:           "scheduled_at",
}

// Generated where

type whereHelperint64 struct{ field string }

func (w whereHelperint64) EQ(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint64) NEQ(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint64) LT(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint64) LTE(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint64) GT(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint64) GTE(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint64) IN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint64) NIN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpernull_String struct{ field string }

func (w whereHelpernull_String) EQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_String) NEQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_String) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_String) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_String) LT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_String) LTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_String) GT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_String) GTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpernull_Float64 struct{ field string }

func (w whereHelpernull_Float64) EQ(x null.Float64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Float64) NEQ(x null.Float64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Float64) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Float64) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_Float64) LT(x null.Float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Float64) LTE(x null.Float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Float64) GT(x null.Float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Float64) GTE(x null.Float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpernull_JSON struct{ field string }

func (w whereHelpernull_JSON) EQ(x null.JSON) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_JSON) NEQ(x null.JSON) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_JSON) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_JSON) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_JSON) LT(x null.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_JSON) LTE(x null.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_JSON) GT(x null.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_JSON) GTE(x null.JSON) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

var LotWhere = struct {
	ID                    whereHelperint
	OwnerID               whereHelperint
	ExternalID            whereHelperint64
	Name                  whereHelperstring
	Avatar                whereHelpernull_String
	Username              whereHelpernull_String
	JoinLink              whereHelpernull_String
	PriceCurrent          whereHelperint
	PricePrevious         whereHelpernull_Int
	PriceIsBargain        whereHelperbool
	Comment               whereHelperstring
	MetricsMembersCount   whereHelperint
	MetricsDailyCoverage  whereHelperint
	MetricsMonthlyIncome  whereHelperint
	MetricsPricePerMember whereHelperfloat64
	MetricsPricePerView   whereHelperfloat64
	MetricsPaybackPeriod  whereHelpernull_Float64
	ExtraResources        whereHelpernull_JSON
	CreatedAt             whereHelpertime_Time
	PaidAt                whereHelpernull_Time
	ApprovedAt            whereHelpernull_Time
	PublishedAt           whereHelpernull_Time
	Status                whereHelperstring
	CanceledReasonID      whereHelpernull_Int
	Bio                   whereHelpernull_String
	ViewsTelegram         whereHelperint
	ViewsSite             whereHelperint
	DeclineReason         whereHelpernull_String
	ScheduledAt           whereHelpernull_Time
}{
	ID:                    whereHelperint{field: "\"lot\".\"id\""},
	OwnerID:               whereHelperint{field: "\"lot\".\"owner_id\""},
	ExternalID:            whereHelperint64{field: "\"lot\".\"external_id\""},
	Name:                  whereHelperstring{field: "\"lot\".\"name\""},
	Avatar:                whereHelpernull_String{field: "\"lot\".\"avatar\""},
	Username:              whereHelpernull_String{field: "\"lot\".\"username\""},
	JoinLink:              whereHelpernull_String{field: "\"lot\".\"join_link\""},
	PriceCurrent:          whereHelperint{field: "\"lot\".\"price_current\""},
	PricePrevious:         whereHelpernull_Int{field: "\"lot\".\"price_previous\""},
	PriceIsBargain:        whereHelperbool{field: "\"lot\".\"price_is_bargain\""},
	Comment:               whereHelperstring{field: "\"lot\".\"comment\""},
	MetricsMembersCount:   whereHelperint{field: "\"lot\".\"metrics_members_count\""},
	MetricsDailyCoverage:  whereHelperint{field: "\"lot\".\"metrics_daily_coverage\""},
	MetricsMonthlyIncome:  whereHelperint{field: "\"lot\".\"metrics_monthly_income\""},
	MetricsPricePerMember: whereHelperfloat64{field: "\"lot\".\"metrics_price_per_member\""},
	MetricsPricePerView:   whereHelperfloat64{field: "\"lot\".\"metrics_price_per_view\""},
	MetricsPaybackPeriod:  whereHelpernull_Float64{field: "\"lot\".\"metrics_payback_period\""},
	ExtraResources:        whereHelpernull_JSON{field: "\"lot\".\"extra_resources\""},
	CreatedAt:             whereHelpertime_Time{field: "\"lot\".\"created_at\""},
	PaidAt:                whereHelpernull_Time{field: "\"lot\".\"paid_at\""},
	ApprovedAt:            whereHelpernull_Time{field: "\"lot\".\"approved_at\""},
	PublishedAt:           whereHelpernull_Time{field: "\"lot\".\"published_at\""},
	Status:                whereHelperstring{field: "\"lot\".\"status\""},
	CanceledReasonID:      whereHelpernull_Int{field: "\"lot\".\"canceled_reason_id\""},
	Bio:                   whereHelpernull_String{field: "\"lot\".\"bio\""},
	ViewsTelegram:         whereHelperint{field: "\"lot\".\"views_telegram\""},
	ViewsSite:             whereHelperint{field: "\"lot\".\"views_site\""},
	DeclineReason:         whereHelpernull_String{field: "\"lot\".\"decline_reason\""},
	ScheduledAt:           whereHelpernull_Time{field: "\"lot\".\"scheduled_at\""},
}

// LotRels is where relationship names are stored.
var LotRels = struct {
	CanceledReason string
	Owner          string
	Favorites      string
	LotFiles       string
	LotTopics      string
	Payments       string
	Posts          string
}{
	CanceledReason: "CanceledReason",
	Owner:          "Owner",
	Favorites:      "Favorites",
	LotFiles:       "LotFiles",
	LotTopics:      "LotTopics",
	Payments:       "Payments",
	Posts:          "Posts",
}

// lotR is where relationships are stored.
type lotR struct {
	CanceledReason *LotCanceledReason `boil:"CanceledReason" json:"CanceledReason" toml:"CanceledReason" yaml:"CanceledReason"`
	Owner          *User              `boil:"Owner" json:"Owner" toml:"Owner" yaml:"Owner"`
	Favorites      FavoriteSlice      `boil:"Favorites" json:"Favorites" toml:"Favorites" yaml:"Favorites"`
	LotFiles       LotFileSlice       `boil:"LotFiles" json:"LotFiles" toml:"LotFiles" yaml:"LotFiles"`
	LotTopics      LotTopicSlice      `boil:"LotTopics" json:"LotTopics" toml:"LotTopics" yaml:"LotTopics"`
	Payments       PaymentSlice       `boil:"Payments" json:"Payments" toml:"Payments" yaml:"Payments"`
	Posts          PostSlice          `boil:"Posts" json:"Posts" toml:"Posts" yaml:"Posts"`
}

// NewStruct creates a new relationship struct
func (*lotR) NewStruct() *lotR {
	return &lotR{}
}

// lotL is where Load methods for each relationship are stored.
type lotL struct{}

var (
	lotAllColumns            = []string{"id", "owner_id", "external_id", "name", "avatar", "username", "join_link", "price_current", "price_previous", "price_is_bargain", "comment", "metrics_members_count", "metrics_daily_coverage", "metrics_monthly_income", "metrics_price_per_member", "metrics_price_per_view", "metrics_payback_period", "extra_resources", "created_at", "paid_at", "approved_at", "published_at", "status", "canceled_reason_id", "bio", "views_telegram", "views_site", "decline_reason", "scheduled_at"}
	lotColumnsWithoutDefault = []string{"owner_id", "external_id", "name", "avatar", "username", "join_link", "price_current", "price_previous", "price_is_bargain", "comment", "metrics_members_count", "metrics_daily_coverage", "metrics_monthly_income", "metrics_price_per_member", "metrics_price_per_view", "metrics_payback_period", "extra_resources", "created_at", "paid_at", "approved_at", "published_at", "status", "canceled_reason_id", "bio", "decline_reason", "scheduled_at"}
	lotColumnsWithDefault    = []string{"id", "views_telegram", "views_site"}
	lotPrimaryKeyColumns     = []string{"id"}
)

type (
	// LotSlice is an alias for a slice of pointers to Lot.
	// This should generally be used opposed to []Lot.
	LotSlice []*Lot

	lotQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	lotType                 = reflect.TypeOf(&Lot{})
	lotMapping              = queries.MakeStructMapping(lotType)
	lotPrimaryKeyMapping, _ = queries.BindMapping(lotType, lotMapping, lotPrimaryKeyColumns)
	lotInsertCacheMut       sync.RWMutex
	lotInsertCache          = make(map[string]insertCache)
	lotUpdateCacheMut       sync.RWMutex
	lotUpdateCache          = make(map[string]updateCache)
	lotUpsertCacheMut       sync.RWMutex
	lotUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// One returns a single lot record from the query.
func (q lotQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Lot, error) {
	o := &Lot{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dal: failed to execute a one query for lot")
	}

	return o, nil
}

// All returns all Lot records from the query.
func (q lotQuery) All(ctx context.Context, exec boil.ContextExecutor) (LotSlice, error) {
	var o []*Lot

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "dal: failed to assign all query results to Lot slice")
	}

	return o, nil
}

// Count returns the count of all Lot records in the query.
func (q lotQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "dal: failed to count lot rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q lotQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "dal: failed to check if lot exists")
	}

	return count > 0, nil
}

// CanceledReason pointed to by the foreign key.
func (o *Lot) CanceledReason(mods ...qm.QueryMod) lotCanceledReasonQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.CanceledReasonID),
	}

	queryMods = append(queryMods, mods...)

	query := LotCanceledReasons(queryMods...)
	queries.SetFrom(query.Query, "\"lot_canceled_reason\"")

	return query
}

// Owner pointed to by the foreign key.
func (o *Lot) Owner(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.OwnerID),
	}

	queryMods = append(queryMods, mods...)

	query := Users(queryMods...)
	queries.SetFrom(query.Query, "\"user\"")

	return query
}

// Favorites retrieves all the favorite's Favorites with an executor.
func (o *Lot) Favorites(mods ...qm.QueryMod) favoriteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"favorite\".\"lot_id\"=?", o.ID),
	)

	query := Favorites(queryMods...)
	queries.SetFrom(query.Query, "\"favorite\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"favorite\".*"})
	}

	return query
}

// LotFiles retrieves all the lot_file's LotFiles with an executor.
func (o *Lot) LotFiles(mods ...qm.QueryMod) lotFileQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"lot_file\".\"lot_id\"=?", o.ID),
	)

	query := LotFiles(queryMods...)
	queries.SetFrom(query.Query, "\"lot_file\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"lot_file\".*"})
	}

	return query
}

// LotTopics retrieves all the lot_topic's LotTopics with an executor.
func (o *Lot) LotTopics(mods ...qm.QueryMod) lotTopicQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"lot_topic\".\"lot_id\"=?", o.ID),
	)

	query := LotTopics(queryMods...)
	queries.SetFrom(query.Query, "\"lot_topic\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"lot_topic\".*"})
	}

	return query
}

// Payments retrieves all the payment's Payments with an executor.
func (o *Lot) Payments(mods ...qm.QueryMod) paymentQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"payment\".\"lot_id\"=?", o.ID),
	)

	query := Payments(queryMods...)
	queries.SetFrom(query.Query, "\"payment\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"payment\".*"})
	}

	return query
}

// Posts retrieves all the post's Posts with an executor.
func (o *Lot) Posts(mods ...qm.QueryMod) postQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"post\".\"lot_id\"=?", o.ID),
	)

	query := Posts(queryMods...)
	queries.SetFrom(query.Query, "\"post\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"post\".*"})
	}

	return query
}

// LoadCanceledReason allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (lotL) LoadCanceledReason(ctx context.Context, e boil.ContextExecutor, singular bool, maybeLot interface{}, mods queries.Applicator) error {
	var slice []*Lot
	var object *Lot

	if singular {
		object = maybeLot.(*Lot)
	} else {
		slice = *maybeLot.(*[]*Lot)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &lotR{}
		}
		if !queries.IsNil(object.CanceledReasonID) {
			args = append(args, object.CanceledReasonID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &lotR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.CanceledReasonID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.CanceledReasonID) {
				args = append(args, obj.CanceledReasonID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`lot_canceled_reason`),
		qm.WhereIn(`lot_canceled_reason.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load LotCanceledReason")
	}

	var resultSlice []*LotCanceledReason
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice LotCanceledReason")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for lot_canceled_reason")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for lot_canceled_reason")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.CanceledReason = foreign
		if foreign.R == nil {
			foreign.R = &lotCanceledReasonR{}
		}
		foreign.R.CanceledReasonLots = append(foreign.R.CanceledReasonLots, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.CanceledReasonID, foreign.ID) {
				local.R.CanceledReason = foreign
				if foreign.R == nil {
					foreign.R = &lotCanceledReasonR{}
				}
				foreign.R.CanceledReasonLots = append(foreign.R.CanceledReasonLots, local)
				break
			}
		}
	}

	return nil
}

// LoadOwner allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (lotL) LoadOwner(ctx context.Context, e boil.ContextExecutor, singular bool, maybeLot interface{}, mods queries.Applicator) error {
	var slice []*Lot
	var object *Lot

	if singular {
		object = maybeLot.(*Lot)
	} else {
		slice = *maybeLot.(*[]*Lot)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &lotR{}
		}
		args = append(args, object.OwnerID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &lotR{}
			}

			for _, a := range args {
				if a == obj.OwnerID {
					continue Outer
				}
			}

			args = append(args, obj.OwnerID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`user`),
		qm.WhereIn(`user.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for user")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Owner = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.OwnerLots = append(foreign.R.OwnerLots, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.OwnerID == foreign.ID {
				local.R.Owner = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.OwnerLots = append(foreign.R.OwnerLots, local)
				break
			}
		}
	}

	return nil
}

// LoadFavorites allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (lotL) LoadFavorites(ctx context.Context, e boil.ContextExecutor, singular bool, maybeLot interface{}, mods queries.Applicator) error {
	var slice []*Lot
	var object *Lot

	if singular {
		object = maybeLot.(*Lot)
	} else {
		slice = *maybeLot.(*[]*Lot)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &lotR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &lotR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`favorite`),
		qm.WhereIn(`favorite.lot_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load favorite")
	}

	var resultSlice []*Favorite
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice favorite")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on favorite")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for favorite")
	}

	if singular {
		object.R.Favorites = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &favoriteR{}
			}
			foreign.R.Lot = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.LotID {
				local.R.Favorites = append(local.R.Favorites, foreign)
				if foreign.R == nil {
					foreign.R = &favoriteR{}
				}
				foreign.R.Lot = local
				break
			}
		}
	}

	return nil
}

// LoadLotFiles allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (lotL) LoadLotFiles(ctx context.Context, e boil.ContextExecutor, singular bool, maybeLot interface{}, mods queries.Applicator) error {
	var slice []*Lot
	var object *Lot

	if singular {
		object = maybeLot.(*Lot)
	} else {
		slice = *maybeLot.(*[]*Lot)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &lotR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &lotR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`lot_file`),
		qm.WhereIn(`lot_file.lot_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load lot_file")
	}

	var resultSlice []*LotFile
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice lot_file")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on lot_file")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for lot_file")
	}

	if singular {
		object.R.LotFiles = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &lotFileR{}
			}
			foreign.R.Lot = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.LotID) {
				local.R.LotFiles = append(local.R.LotFiles, foreign)
				if foreign.R == nil {
					foreign.R = &lotFileR{}
				}
				foreign.R.Lot = local
				break
			}
		}
	}

	return nil
}

// LoadLotTopics allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (lotL) LoadLotTopics(ctx context.Context, e boil.ContextExecutor, singular bool, maybeLot interface{}, mods queries.Applicator) error {
	var slice []*Lot
	var object *Lot

	if singular {
		object = maybeLot.(*Lot)
	} else {
		slice = *maybeLot.(*[]*Lot)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &lotR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &lotR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`lot_topic`),
		qm.WhereIn(`lot_topic.lot_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load lot_topic")
	}

	var resultSlice []*LotTopic
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice lot_topic")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on lot_topic")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for lot_topic")
	}

	if singular {
		object.R.LotTopics = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &lotTopicR{}
			}
			foreign.R.Lot = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.LotID {
				local.R.LotTopics = append(local.R.LotTopics, foreign)
				if foreign.R == nil {
					foreign.R = &lotTopicR{}
				}
				foreign.R.Lot = local
				break
			}
		}
	}

	return nil
}

// LoadPayments allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (lotL) LoadPayments(ctx context.Context, e boil.ContextExecutor, singular bool, maybeLot interface{}, mods queries.Applicator) error {
	var slice []*Lot
	var object *Lot

	if singular {
		object = maybeLot.(*Lot)
	} else {
		slice = *maybeLot.(*[]*Lot)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &lotR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &lotR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`payment`),
		qm.WhereIn(`payment.lot_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load payment")
	}

	var resultSlice []*Payment
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice payment")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on payment")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for payment")
	}

	if singular {
		object.R.Payments = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &paymentR{}
			}
			foreign.R.Lot = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.LotID {
				local.R.Payments = append(local.R.Payments, foreign)
				if foreign.R == nil {
					foreign.R = &paymentR{}
				}
				foreign.R.Lot = local
				break
			}
		}
	}

	return nil
}

// LoadPosts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (lotL) LoadPosts(ctx context.Context, e boil.ContextExecutor, singular bool, maybeLot interface{}, mods queries.Applicator) error {
	var slice []*Lot
	var object *Lot

	if singular {
		object = maybeLot.(*Lot)
	} else {
		slice = *maybeLot.(*[]*Lot)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &lotR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &lotR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`post`),
		qm.WhereIn(`post.lot_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load post")
	}

	var resultSlice []*Post
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice post")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on post")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for post")
	}

	if singular {
		object.R.Posts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &postR{}
			}
			foreign.R.Lot = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.LotID) {
				local.R.Posts = append(local.R.Posts, foreign)
				if foreign.R == nil {
					foreign.R = &postR{}
				}
				foreign.R.Lot = local
				break
			}
		}
	}

	return nil
}

// SetCanceledReason of the lot to the related item.
// Sets o.R.CanceledReason to related.
// Adds o to related.R.CanceledReasonLots.
func (o *Lot) SetCanceledReason(ctx context.Context, exec boil.ContextExecutor, insert bool, related *LotCanceledReason) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"lot\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"canceled_reason_id"}),
		strmangle.WhereClause("\"", "\"", 2, lotPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.CanceledReasonID, related.ID)
	if o.R == nil {
		o.R = &lotR{
			CanceledReason: related,
		}
	} else {
		o.R.CanceledReason = related
	}

	if related.R == nil {
		related.R = &lotCanceledReasonR{
			CanceledReasonLots: LotSlice{o},
		}
	} else {
		related.R.CanceledReasonLots = append(related.R.CanceledReasonLots, o)
	}

	return nil
}

// RemoveCanceledReason relationship.
// Sets o.R.CanceledReason to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Lot) RemoveCanceledReason(ctx context.Context, exec boil.ContextExecutor, related *LotCanceledReason) error {
	var err error

	queries.SetScanner(&o.CanceledReasonID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("canceled_reason_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.CanceledReason = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.CanceledReasonLots {
		if queries.Equal(o.CanceledReasonID, ri.CanceledReasonID) {
			continue
		}

		ln := len(related.R.CanceledReasonLots)
		if ln > 1 && i < ln-1 {
			related.R.CanceledReasonLots[i] = related.R.CanceledReasonLots[ln-1]
		}
		related.R.CanceledReasonLots = related.R.CanceledReasonLots[:ln-1]
		break
	}
	return nil
}

// SetOwner of the lot to the related item.
// Sets o.R.Owner to related.
// Adds o to related.R.OwnerLots.
func (o *Lot) SetOwner(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"lot\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"owner_id"}),
		strmangle.WhereClause("\"", "\"", 2, lotPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.OwnerID = related.ID
	if o.R == nil {
		o.R = &lotR{
			Owner: related,
		}
	} else {
		o.R.Owner = related
	}

	if related.R == nil {
		related.R = &userR{
			OwnerLots: LotSlice{o},
		}
	} else {
		related.R.OwnerLots = append(related.R.OwnerLots, o)
	}

	return nil
}

// AddFavorites adds the given related objects to the existing relationships
// of the lot, optionally inserting them as new records.
// Appends related to o.R.Favorites.
// Sets related.R.Lot appropriately.
func (o *Lot) AddFavorites(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Favorite) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.LotID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"favorite\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"lot_id"}),
				strmangle.WhereClause("\"", "\"", 2, favoritePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.LotID = o.ID
		}
	}

	if o.R == nil {
		o.R = &lotR{
			Favorites: related,
		}
	} else {
		o.R.Favorites = append(o.R.Favorites, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &favoriteR{
				Lot: o,
			}
		} else {
			rel.R.Lot = o
		}
	}
	return nil
}

// AddLotFiles adds the given related objects to the existing relationships
// of the lot, optionally inserting them as new records.
// Appends related to o.R.LotFiles.
// Sets related.R.Lot appropriately.
func (o *Lot) AddLotFiles(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*LotFile) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.LotID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"lot_file\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"lot_id"}),
				strmangle.WhereClause("\"", "\"", 2, lotFilePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.LotID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &lotR{
			LotFiles: related,
		}
	} else {
		o.R.LotFiles = append(o.R.LotFiles, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &lotFileR{
				Lot: o,
			}
		} else {
			rel.R.Lot = o
		}
	}
	return nil
}

// SetLotFiles removes all previously related items of the
// lot replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Lot's LotFiles accordingly.
// Replaces o.R.LotFiles with related.
// Sets related.R.Lot's LotFiles accordingly.
func (o *Lot) SetLotFiles(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*LotFile) error {
	query := "update \"lot_file\" set \"lot_id\" = null where \"lot_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.LotFiles {
			queries.SetScanner(&rel.LotID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Lot = nil
		}

		o.R.LotFiles = nil
	}
	return o.AddLotFiles(ctx, exec, insert, related...)
}

// RemoveLotFiles relationships from objects passed in.
// Removes related items from R.LotFiles (uses pointer comparison, removal does not keep order)
// Sets related.R.Lot.
func (o *Lot) RemoveLotFiles(ctx context.Context, exec boil.ContextExecutor, related ...*LotFile) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.LotID, nil)
		if rel.R != nil {
			rel.R.Lot = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("lot_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.LotFiles {
			if rel != ri {
				continue
			}

			ln := len(o.R.LotFiles)
			if ln > 1 && i < ln-1 {
				o.R.LotFiles[i] = o.R.LotFiles[ln-1]
			}
			o.R.LotFiles = o.R.LotFiles[:ln-1]
			break
		}
	}

	return nil
}

// AddLotTopics adds the given related objects to the existing relationships
// of the lot, optionally inserting them as new records.
// Appends related to o.R.LotTopics.
// Sets related.R.Lot appropriately.
func (o *Lot) AddLotTopics(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*LotTopic) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.LotID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"lot_topic\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"lot_id"}),
				strmangle.WhereClause("\"", "\"", 2, lotTopicPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.LotID = o.ID
		}
	}

	if o.R == nil {
		o.R = &lotR{
			LotTopics: related,
		}
	} else {
		o.R.LotTopics = append(o.R.LotTopics, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &lotTopicR{
				Lot: o,
			}
		} else {
			rel.R.Lot = o
		}
	}
	return nil
}

// AddPayments adds the given related objects to the existing relationships
// of the lot, optionally inserting them as new records.
// Appends related to o.R.Payments.
// Sets related.R.Lot appropriately.
func (o *Lot) AddPayments(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Payment) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.LotID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"payment\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"lot_id"}),
				strmangle.WhereClause("\"", "\"", 2, paymentPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.LotID = o.ID
		}
	}

	if o.R == nil {
		o.R = &lotR{
			Payments: related,
		}
	} else {
		o.R.Payments = append(o.R.Payments, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &paymentR{
				Lot: o,
			}
		} else {
			rel.R.Lot = o
		}
	}
	return nil
}

// AddPosts adds the given related objects to the existing relationships
// of the lot, optionally inserting them as new records.
// Appends related to o.R.Posts.
// Sets related.R.Lot appropriately.
func (o *Lot) AddPosts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Post) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.LotID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"post\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"lot_id"}),
				strmangle.WhereClause("\"", "\"", 2, postPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.LotID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &lotR{
			Posts: related,
		}
	} else {
		o.R.Posts = append(o.R.Posts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &postR{
				Lot: o,
			}
		} else {
			rel.R.Lot = o
		}
	}
	return nil
}

// SetPosts removes all previously related items of the
// lot replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Lot's Posts accordingly.
// Replaces o.R.Posts with related.
// Sets related.R.Lot's Posts accordingly.
func (o *Lot) SetPosts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Post) error {
	query := "update \"post\" set \"lot_id\" = null where \"lot_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.Posts {
			queries.SetScanner(&rel.LotID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Lot = nil
		}

		o.R.Posts = nil
	}
	return o.AddPosts(ctx, exec, insert, related...)
}

// RemovePosts relationships from objects passed in.
// Removes related items from R.Posts (uses pointer comparison, removal does not keep order)
// Sets related.R.Lot.
func (o *Lot) RemovePosts(ctx context.Context, exec boil.ContextExecutor, related ...*Post) error {
	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.LotID, nil)
		if rel.R != nil {
			rel.R.Lot = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("lot_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Posts {
			if rel != ri {
				continue
			}

			ln := len(o.R.Posts)
			if ln > 1 && i < ln-1 {
				o.R.Posts[i] = o.R.Posts[ln-1]
			}
			o.R.Posts = o.R.Posts[:ln-1]
			break
		}
	}

	return nil
}

// Lots retrieves all the records using an executor.
func Lots(mods ...qm.QueryMod) lotQuery {
	mods = append(mods, qm.From("\"lot\""))
	return lotQuery{NewQuery(mods...)}
}

// FindLot retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindLot(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*Lot, error) {
	lotObj := &Lot{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"lot\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, lotObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "dal: unable to select from lot")
	}

	return lotObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Lot) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("dal: no lot provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(lotColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	lotInsertCacheMut.RLock()
	cache, cached := lotInsertCache[key]
	lotInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			lotAllColumns,
			lotColumnsWithDefault,
			lotColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(lotType, lotMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(lotType, lotMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"lot\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"lot\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "dal: unable to insert into lot")
	}

	if !cached {
		lotInsertCacheMut.Lock()
		lotInsertCache[key] = cache
		lotInsertCacheMut.Unlock()
	}

	return nil
}

// Update uses an executor to update the Lot.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Lot) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	key := makeCacheKey(columns, nil)
	lotUpdateCacheMut.RLock()
	cache, cached := lotUpdateCache[key]
	lotUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			lotAllColumns,
			lotPrimaryKeyColumns,
		)

		if len(wl) == 0 {
			return 0, errors.New("dal: unable to update lot, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"lot\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, lotPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(lotType, lotMapping, append(wl, lotPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "dal: unable to update lot row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dal: failed to get rows affected by update for lot")
	}

	if !cached {
		lotUpdateCacheMut.Lock()
		lotUpdateCache[key] = cache
		lotUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values.
func (q lotQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dal: unable to update all for lot")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dal: unable to retrieve rows affected for lot")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o LotSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("dal: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), lotPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"lot\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, lotPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dal: unable to update all in lot slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dal: unable to retrieve rows affected all in update all lot")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Lot) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("dal: no lot provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(lotColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	lotUpsertCacheMut.RLock()
	cache, cached := lotUpsertCache[key]
	lotUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			lotAllColumns,
			lotColumnsWithDefault,
			lotColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			lotAllColumns,
			lotPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("dal: unable to upsert lot, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(lotPrimaryKeyColumns))
			copy(conflict, lotPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"lot\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(lotType, lotMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(lotType, lotMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "dal: unable to upsert lot")
	}

	if !cached {
		lotUpsertCacheMut.Lock()
		lotUpsertCache[key] = cache
		lotUpsertCacheMut.Unlock()
	}

	return nil
}

// Delete deletes a single Lot record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Lot) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("dal: no Lot provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), lotPrimaryKeyMapping)
	sql := "DELETE FROM \"lot\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dal: unable to delete from lot")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dal: failed to get rows affected by delete for lot")
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q lotQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("dal: no lotQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "dal: unable to delete all from lot")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dal: failed to get rows affected by deleteall for lot")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o LotSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), lotPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"lot\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, lotPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "dal: unable to delete all from lot slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "dal: failed to get rows affected by deleteall for lot")
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Lot) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindLot(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *LotSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := LotSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), lotPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"lot\".* FROM \"lot\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, lotPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "dal: unable to reload all in LotSlice")
	}

	*o = slice

	return nil
}

// LotExists checks if the Lot row exists.
func LotExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"lot\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "dal: unable to check if lot exists")
	}

	return exists, nil
}
